===================
Custom Observations
===================

This tutorial explains how to create custom observation spaces in JobShopLab. Custom observation spaces allow you to define exactly what information is available to your agents, which can significantly impact learning performance.

Creating a Custom Observation Factory
------------------------------------

In JobShopLab, observations are generated by observation factories. To create a custom observation space, you'll need to implement a custom observation factory:

.. code-block:: python

    from jobshoplab.env.factories.observation_factories import ObservationFactory
    from gymnasium import spaces
    import numpy as np

    class MyCustomObservationFactory(ObservationFactory):
        def __init__(self, state_machine):
            super().__init__(state_machine)
            # Define your observation space parameters here
            self.num_machines = len(state_machine.state.machines)
            self.num_jobs = len(state_machine.state.jobs)
            
        def get_observation_space(self):
            # Define your custom observation space structure
            return spaces.Dict({
                "machine_status": spaces.Box(
                    low=0, high=1, shape=(self.num_machines,), dtype=np.float32
                ),
                "job_progress": spaces.Box(
                    low=0, high=1, shape=(self.num_jobs,), dtype=np.float32
                ),
                # Add more observation components as needed
            })
            
        def get_observation(self):
            # Extract relevant information from the state
            state = self.state_machine.state
            
            # Create your custom observation components
            machine_status = np.zeros(self.num_machines, dtype=np.float32)
            for i, machine in enumerate(state.machines.values()):
                machine_status[i] = 1.0 if machine.status == "busy" else 0.0
                
            job_progress = np.zeros(self.num_jobs, dtype=np.float32)
            for i, job in enumerate(state.jobs.values()):
                completed_operations = sum(1 for op in job.operations if op.completed)
                total_operations = len(job.operations)
                job_progress[i] = completed_operations / total_operations if total_operations > 0 else 0.0
            
            # Return the complete observation
            return {
                "machine_status": machine_status,
                "job_progress": job_progress,
            }

Using Your Custom Observation Factory
------------------------------------

Once you've implemented your custom observation factory, you can use it by specifying it in your environment configuration:

.. code-block:: yaml

    # In your configuration file
    env:
      observation_factory:
        type: "MyCustomObservationFactory"
        module: "my_module.observation_factories"  # The module where your factory is defined

Or directly when creating your environment:

.. code-block:: python

    from jobshoplab import JobShopLabEnv, load_config
    from my_module.observation_factories import MyCustomObservationFactory
    
    # Load your config
    config = load_config("path/to/config.yaml")
    
    # Create the environment with your custom observation factory
    env = JobShopLabEnv(
        config=config, 
        observation_factory_cls=MyCustomObservationFactory
    )
    
    # Now observations will use your custom format
    obs, _ = env.reset()
    print(obs)  # Will show your custom observation structure

Observation Design Best Practices
--------------------------------

When designing your observation space, consider these best practices:

1. **Normalization**: Keep observation values normalized (typically between 0 and 1) to improve learning stability.

2. **Relevant information**: Only include information that is relevant to the decision-making process.

3. **Consistency**: Ensure the observation space structure remains consistent throughout an episode.

4. **Dimensionality**: Be mindful of the observation space dimension - larger spaces can slow down learning.

5. **Time-related features**: Consider including features related to time progression, deadlines, and expected completion times.

Example: Global State Observation
-------------------------------

Here's an example of an observation factory that provides a global view of the entire state:

.. code-block:: python

    class GlobalStateObservationFactory(ObservationFactory):
        def __init__(self, state_machine):
            super().__init__(state_machine)
            self.num_machines = len(state_machine.state.machines)
            self.num_jobs = len(state_machine.state.jobs)
            self.max_operations = max(len(job.operations) for job in state_machine.state.jobs.values())
            
        def get_observation_space(self):
            return spaces.Dict({
                "machine_status": spaces.Box(
                    low=0, high=1, shape=(self.num_machines,), dtype=np.float32
                ),
                "job_machine_matrix": spaces.Box(
                    low=0, high=1, shape=(self.num_jobs, self.num_machines), dtype=np.float32
                ),
                "job_progress": spaces.Box(
                    low=0, high=1, shape=(self.num_jobs,), dtype=np.float32
                ),
                "operation_times": spaces.Box(
                    low=0, high=1, shape=(self.num_jobs, self.max_operations), dtype=np.float32
                ),
            })
            
        def get_observation(self):
            state = self.state_machine.state
            
            # Machine status (busy/idle)
            machine_status = np.zeros(self.num_machines, dtype=np.float32)
            for i, machine in enumerate(state.machines.values()):
                machine_status[i] = 1.0 if machine.status == "busy" else 0.0
            
            # Job-machine matrix (which job needs which machine)
            job_machine_matrix = np.zeros((self.num_jobs, self.num_machines), dtype=np.float32)
            for j, job in enumerate(state.jobs.values()):
                for op in job.operations:
                    if not op.completed:
                        m = list(state.machines.values()).index(op.machine)
                        job_machine_matrix[j, m] = 1.0
                        break
            
            # Job progress
            job_progress = np.zeros(self.num_jobs, dtype=np.float32)
            for j, job in enumerate(state.jobs.values()):
                completed = sum(1 for op in job.operations if op.completed)
                job_progress[j] = completed / len(job.operations)
            
            # Operation processing times (normalized)
            max_time = max(op.processing_time for job in state.jobs.values() for op in job.operations)
            operation_times = np.zeros((self.num_jobs, self.max_operations), dtype=np.float32)
            for j, job in enumerate(state.jobs.values()):
                for i, op in enumerate(job.operations):
                    operation_times[j, i] = op.processing_time / max_time if max_time > 0 else 0.0
            
            return {
                "machine_status": machine_status,
                "job_machine_matrix": job_machine_matrix,
                "job_progress": job_progress,
                "operation_times": operation_times,
            }

This observation factory provides a comprehensive view of the scheduling environment, including machine status, job-machine requirements, job progress, and operation processing times.